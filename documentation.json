[
  {
    "name": "Utils.Json",
    "comment": " Utility JSON functions.\n\n@docs (///), (<||), decConvertDict, decDict, encDict, encMaybe, resultEncoder, resultDecoder, resultEncode, resultDecode\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "///",
        "comment": " Operator to provide a default for a Decoder.\n\n    type alias User =\n        { name : String\n        , age : Int\n        , amount : Float\n        , twelve : Int\n        , address : Address\n        }\n\n    userDecoder : Json.Decoder User\n    userDecoder =\n        Json.succeed User\n            <|| (\"name\" := string)\n            <|| (\"age\" := int)\n            <|| ((\"amount\" := float) /// 100)\n            <|| Json.succeed 12\n            <|| (\"address\" := addressDecoder)\n\n",
        "type": "Json.Decode.Decoder a -> a -> Json.Decode.Decoder a"
      },
      {
        "name": "<||",
        "comment": " Operator to allow stringing decoders together to construct a record via its constructor.\n\n    type alias User =\n        { name : String\n        , age : Int\n        , amount : Float\n        , twelve : Int\n        , address : Address\n        }\n\n    userDecoder : Json.Decoder User\n    userDecoder =\n        Json.succeed User\n            <|| (\"name\" := string)\n            <|| (\"age\" := int)\n            <|| (\"amount\" := float)\n            <|| Json.succeed 12\n            <|| (\"address\" := addressDecoder)\n\n",
        "type": "Json.Decode.Decoder (a -> b) -> Json.Decode.Decoder a -> Json.Decode.Decoder b"
      },
      {
        "name": "decConvertDict",
        "comment": " Convenience function for decoding a Dictionary WITH a value converstion function from a JS object of the following form:\n\n```js\n{\n    keys: [\n        // keys encoded here\n    ],\n    values: [\n        // values encoded here\n    ]\n}\n```\n\n    import Json.Decode as JD exposing (..)\n\n    type alias Model =\n        { ids : Dict Int (Set String)\n        , ages : Dict String Int\n        }\n\n    -- here json is a JSON string that was generated by encDict\n    JD.decodeString\n        ((JD.succeed Model)\n            <|| (\"ids\" := Json.decConvertDict Set.fromList JD.int (JD.list JD.string))\n            <|| (\"ages\" := Json.decDict JD.string JD.int)\n        )\n        json\n\n",
        "type": "(a -> value) -> Json.Decode.Decoder comparable -> Json.Decode.Decoder a -> Json.Decode.Decoder (Dict.Dict comparable value)"
      },
      {
        "name": "decDict",
        "comment": " Convenience function for decoding a Dictionary WITHOUT a value conversion function.\n\nfrom a JS object of the following form:\n\n```js\n{\n   keys: [\n       // keys encoded here\n   ],\n   values: [\n       // values encoded here\n   ]\n}\n```\n\n    import Json.Decode as JD exposing (..)\n\n    type alias Model =\n       { ids : Dict Int (Set String)\n       , ages : Dict String Int\n       }\n\n    -- here json is a JSON string that was generated by encDict\n    JD.decodeString\n       ((JD.succeed Model)\n           <|| (\"ids\" := Json.decConvertDict Set.fromList JD.int (JD.list JD.string))\n           <|| (\"ages\" := Json.decDict JD.string JD.int)\n       )\n       json\n\n",
        "type": "Json.Decode.Decoder comparable -> Json.Decode.Decoder value -> Json.Decode.Decoder (Dict.Dict comparable value)"
      },
      {
        "name": "encDict",
        "comment": " Convenience function for encoding a Dictionary to a JS object of the following form:\n\n```js\n{\n    keys: [\n        // keys encoded here\n    ],\n    values: [\n        // values encoded here\n    ]\n}\n```\n\n    import Json.Encode as JE exposing (..)\n\n    type alias Model =\n        { ids : Dict Int (Set String)\n        , ages : Dict String Int\n        }\n\n    JE.encode 0 <|\n        JE.object\n            [ ( \"ids\", Json.encDict JE.int (JE.list << List.map JE.string << Set.toList) model.ids )\n            , ( \"ages\", Json.encDict JE.string JE.int model.ages )\n            ]\n\n",
        "type": "(comparable -> Json.Encode.Value) -> (value -> Json.Encode.Value) -> Dict.Dict comparable value -> Json.Encode.Value"
      },
      {
        "name": "encMaybe",
        "comment": " Convenience function for encoding a Maybe with a encoder and NULL default.\n\n    import Json.Encode as JE exposing (..)\n\n    JE.encode 0 <|\n        JE.object\n            [ ( \"street\", Json.encMaybe JE.string address.street )\n            , ( \"city\", Json.encMaybe JE.string address.city )\n            , ( \"state\", Json.encMaybe JE.string address.state )\n            , ( \"zip\", Json.encMaybe JE.string address.zip )\n            ]\n\n",
        "type": "(a -> Json.Encode.Value) -> Maybe.Maybe a -> Json.Encode.Value"
      },
      {
        "name": "resultDecode",
        "comment": " Decode Elm Result\n\nExpects a JS object with either an `okay` key or an `error` key.\n\n    type alias MyResult =\n        Result String Int\n\n    decodedErrorResult : Result String MyResult\n    decodedErrorResult =\n        resultDecode JD.string JD.int \"\"\"{\"error\": \"This is an error\"}\"\"\"\n\n    decodedOkayResult : Result String MyResult\n    decodedOkayResult =\n        resultDecode JD.string JD.int \"\"\"{\"okay\": 123}\"\"\"\n\n",
        "type": "Json.Decode.Decoder error -> Json.Decode.Decoder okay -> String -> Result.Result String (Result.Result error okay)"
      },
      {
        "name": "resultDecoder",
        "comment": " Elm Result decoder\n\nExpects a JS object with either an `okay` key or an `error` key.\n\n    import Json.Decode as JD exposing (..)\n\n    type alias Thing =\n        { id : Int\n        , result : Result String Int\n        }\n\n    thingDecoder : Decoder Thing\n    thingDecoder =\n        (JD.succeed Thing)\n            <|| (field \"id\" JD.int)\n            <|| (field \"result\" <| resultDecoder JD.string JD.int)\n\n",
        "type": "Json.Decode.Decoder error -> Json.Decode.Decoder okay -> Json.Decode.Decoder (Result.Result error okay)"
      },
      {
        "name": "resultEncode",
        "comment": " Encode Elm Result\n\nWill create a JS object with either an `okay` key or an `error` key.\n\n    import Json.Encode as JE exposing (..)\n\n    type alias MyResult =\n        Result String Int\n\n    encodedErrorResult : String\n    encodedErrorResult =\n        resultEncode JE.string JE.int <| Err \"This is an error\"\n\n    encodedOkayResult : String\n    encodedOkayResult =\n        resultEncode JE.string JE.int <| Ok 123\n\n",
        "type": "(error -> Json.Encode.Value) -> (okay -> Json.Encode.Value) -> Result.Result error okay -> String"
      },
      {
        "name": "resultEncoder",
        "comment": " Elm Result encoder\n\nWill create a JS object with either an `okay` key or an `error` key.\n\n    import Json.Encode as JE exposing (..)\n\n    type alias Thing =\n    { id : Int\n    , result : Result String Int\n    }\n\n    thingEncoder : Thing -> JE.Value\n    thingEncoder thing =\n    JE.object\n    [ ( \"id\", JE.int thing.id )\n    , ( \"result\", resultEncoder JE.string JE.int thing.result )\n    ]\n\n",
        "type": "(error -> Json.Encode.Value) -> (okay -> Json.Encode.Value) -> Result.Result error okay -> Json.Encode.Value"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Utils.Task",
    "comment": " Utility Task functions.\n\n@docs untilSuccess, andThenIf, sequence2, sequence3, sequence4, sequence5, sequence6, sequence7, sequence8, sequence9\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "andThenIf",
        "comment": " Conditional Task.andThen\n\nThis function helps reduces code clutter (by 2 lines).\n\n    with : Bool -> Task String ()\n    with flag =\n        Task.succeed ()\n            |> Task.andThen (\\_ -> Task.succeed ())\n            |> andThenIf flag\n                ( \\_ -> Task.succeed ()\n                , always <| Task.fail \"flag not set\"\n                )\n\n    without : Bool -> Task String ()\n    without flag =\n        Task.succeed ()\n            |> Task.andThen (\\_ -> Task.succeed ())\n            |> Task.andThen\n                (flag\n                    ? ( \\_ -> Task.succeed ()\n                      , always <| Task.fail \"flag not set\"\n                      )\n                )\n\n",
        "type": "Bool -> ( a -> Task.Task x b, a -> Task.Task x b ) -> Task.Task x a -> Task.Task x b"
      },
      {
        "name": "sequence2",
        "comment": " Sequence 2 Tasks of similar error types but differing success types\n\nThis function helps reduces indent hell especially with higher numbers of tasks.\n\nOld way:\n\n    getCountTask\n        |> Task.andThen\n            (\\count ->\n                getNameTask\n                    |> Task.andThen (\\name -> name ++ \":\" ++ count)\n            )\n\nNew way:\n\n    ( getCountTask, getNameTask )\n        |> sequence2\n        |> Task.andThen (\\( count, name ) -> name ++ \":\" ++ count)\n\n",
        "type": "( Task.Task x a, Task.Task x b ) -> Task.Task x ( a, b )"
      },
      {
        "name": "sequence3",
        "comment": " Sequence 3 Tasks of similar error types but differing success types\n",
        "type": "( Task.Task x a, Task.Task x b, Task.Task x c ) -> Task.Task x ( a, b, c )"
      },
      {
        "name": "sequence4",
        "comment": " Sequence 4 Tasks of similar error types but differing success types\n",
        "type": "( Task.Task x a, Task.Task x b, Task.Task x c, Task.Task x d ) -> Task.Task x ( a, b, c, d )"
      },
      {
        "name": "sequence5",
        "comment": " Sequence 5 Tasks of similar error types but differing success types\n",
        "type": "( Task.Task x a , Task.Task x b , Task.Task x c , Task.Task x d , Task.Task x e ) -> Task.Task x ( a, b, c, d, e )"
      },
      {
        "name": "sequence6",
        "comment": " Sequence 6 Tasks of similar error types but differing success types\n",
        "type": "( Task.Task x a , Task.Task x b , Task.Task x c , Task.Task x d , Task.Task x e , Task.Task x f ) -> Task.Task x ( a, b, c, d, e, f )"
      },
      {
        "name": "sequence7",
        "comment": " Sequence 7 Tasks of similar error types but differing success types\n",
        "type": "( Task.Task x a , Task.Task x b , Task.Task x c , Task.Task x d , Task.Task x e , Task.Task x f , Task.Task x g ) -> Task.Task x ( a, b, c, d, e, f, g )"
      },
      {
        "name": "sequence8",
        "comment": " Sequence 8 Tasks of similar error types but differing success types\n",
        "type": "( Task.Task x a , Task.Task x b , Task.Task x c , Task.Task x d , Task.Task x e , Task.Task x f , Task.Task x g , Task.Task x h ) -> Task.Task x ( a, b, c, d, e, f, g, h )"
      },
      {
        "name": "sequence9",
        "comment": " Sequence 9 Tasks of similar error types but differing success types\n",
        "type": "( Task.Task x a , Task.Task x b , Task.Task x c , Task.Task x d , Task.Task x e , Task.Task x f , Task.Task x g , Task.Task x h , Task.Task x i ) -> Task.Task x ( a, b, c, d, e, f, g, h, i )"
      },
      {
        "name": "untilSuccess",
        "comment": " Execute a list of Tasks from left to right sequentially\nuntil one succeeds at which point processing of the list is terminated.\n\nIf all tasks fail then the `failureValue` is the result of the combined Task.\n\n    tasks : Task String Int\n    tasks =\n        untilSuccess \"None succeeded\" [ Task.fail \"nope\", Task.succeed 1, Task.fail \"never gets executed\", Task.succeed 2 ]\n\n",
        "type": "x -> List (Task.Task x a) -> Task.Task x a"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Utils.Match",
    "comment": " Utility Regex Match functions.\n\n@docs extract1, extract2, extract3, extract4, getSubmatches1, getSubmatches2, getSubmatches3, getSubmatches4\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "extract1",
        "comment": " extract 1 submatch\n",
        "type": "Regex.Match -> Maybe.Maybe (Maybe.Maybe String)"
      },
      {
        "name": "extract2",
        "comment": " Extract 2 from submatch\n\n    import Regex exposing (..)\n    import Utils.Match exposing (..)\n\n    str : String\n    str =\n        \"First second\"\n\n    parseStr : ( Maybe String, Maybe String )\n    parseStr =\n        (str\n            |> find (AtMost 1) (regex \"(\\\\w+)\\\\s+(\\\\w+)\")\n            |> List.head\n        )\n            |?!->\n                ( \\_ -> Debug.crash \"no match\"\n                , extract2\n                )\n            ?!= (\\_ -> Debug.crash \"2 submatches not found\")\n\n",
        "type": "Regex.Match -> Maybe.Maybe ( Maybe.Maybe String, Maybe.Maybe String )"
      },
      {
        "name": "extract3",
        "comment": " extract 3 submatches\n",
        "type": "Regex.Match -> Maybe.Maybe ( Maybe.Maybe String, Maybe.Maybe String, Maybe.Maybe String )"
      },
      {
        "name": "extract4",
        "comment": " extract 4 submatches\n",
        "type": "Regex.Match -> Maybe.Maybe ( Maybe.Maybe String , Maybe.Maybe String , Maybe.Maybe String , Maybe.Maybe String )"
      },
      {
        "name": "getSubmatches1",
        "comment": " get 1 submatch (WILL CRASH IF 1 DOESN'T EXIST!!!!!!)\n",
        "type": "Regex.Match -> String"
      },
      {
        "name": "getSubmatches2",
        "comment": " Get 2 submatches (WILL CRASH IF 2 DON'T EXIST!!!!!!)\n\n    import Regex exposing (..)\n    import Utils.Match exposing (..)\n\n    str : String\n    str =\n        \"First second\"\n\n    parseStr : ( String, String )\n    parseStr =\n        (str\n            |> find (AtMost 1) (regex \"(\\\\w+)\\\\s+(\\\\w+)\")\n            |> List.head\n        )\n            |?> getSubmatches2\n            ?!= (\\_ -> Debug.crash \"no match\")\n\n",
        "type": "Regex.Match -> ( String, String )"
      },
      {
        "name": "getSubmatches3",
        "comment": " get 3 submatches (WILL CRASH IF 3 DON'T EXIST!!!!!!)\n",
        "type": "Regex.Match -> ( String, String, String )"
      },
      {
        "name": "getSubmatches4",
        "comment": " get 4 submatches (WILL CRASH IF 4 DON'T EXIST!!!!!!)\n",
        "type": "Regex.Match -> ( String, String, String, String )"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Utils.Dict",
    "comment": " Utility Dict functions.\n\n@docs swap, zip\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "swap",
        "comment": " swap dictionary's keys and values - returns Err if values are NOT unique\n",
        "type": "Dict.Dict comparable comparable_ -> Result.Result String (Dict.Dict comparable_ comparable)"
      },
      {
        "name": "zip",
        "comment": " Zip keys and values together into Dictionary.\n\nWhen length of keys != length of values then whichever runs out first will end the zip.\n\n    keys : String\n    keys =\n        [ \"a\"\n        , \"b\"\n        , \"c\"\n        ]\n\n    values : Int\n    values =\n        [ 1\n        , 2\n        , 3\n        ]\n\n    dict : Dict String Int\n    dict =\n        zip keys values\n\n",
        "type": "List comparable -> List a -> Dict.Dict comparable a"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Utils.Tuple",
    "comment": " Utility tuple functions.\n\n@docs firstMap, secondMap, map2, map3, map4, map5, map6, map7, map8, map9\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "firstMap",
        "comment": " Map over List on first item of 2-tuple.\n\n    x : List ( Int, String )\n    x =\n        firstMap (\\num -> 10 * num) [ ( 1, \"Test\" ), ( 2, \"Another\" ) ]\n\n",
        "type": "(a -> b) -> List ( a, c ) -> List ( b, c )"
      },
      {
        "name": "map2",
        "comment": " Map over homogeneous 2-tuple\n",
        "type": "(a -> b) -> ( a, a ) -> ( b, b )"
      },
      {
        "name": "map3",
        "comment": " Map over homogeneous 3-tuple\n",
        "type": "(a -> b) -> ( a, a, a ) -> ( b, b, b )"
      },
      {
        "name": "map4",
        "comment": " Map over homogeneous 4-tuple\n",
        "type": "(a -> b) -> ( a, a, a, a ) -> ( b, b, b, b )"
      },
      {
        "name": "map5",
        "comment": " Map over homogeneous 5-tuple\n",
        "type": "(a -> b) -> ( a, a, a, a, a ) -> ( b, b, b, b, b )"
      },
      {
        "name": "map6",
        "comment": " Map over homogeneous 6-tuple\n",
        "type": "(a -> b) -> ( a, a, a, a, a, a ) -> ( b, b, b, b, b, b )"
      },
      {
        "name": "map7",
        "comment": " Map over homogeneous 7-tuple\n",
        "type": "(a -> b) -> ( a, a, a, a, a, a, a ) -> ( b, b, b, b, b, b, b )"
      },
      {
        "name": "map8",
        "comment": " Map over homogeneous 8-tuple\n",
        "type": "(a -> b) -> ( a, a, a, a, a, a, a, a ) -> ( b, b, b, b, b, b, b, b )"
      },
      {
        "name": "map9",
        "comment": " Map over homogeneous 9-tuple\n",
        "type": "(a -> b) -> ( a, a, a, a, a, a, a, a, a ) -> ( b, b, b, b, b, b, b, b, b )"
      },
      {
        "name": "secondMap",
        "comment": " Map over List on second item of 2-tuple.\n\n    x : List ( Int, String )\n    x =\n        secondMap String.length [ ( 1, \"Test\" ), ( 2, \"Another\" ) ]\n\n",
        "type": "(b -> c) -> List ( a, b ) -> List ( a, c )"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Utils.Result",
    "comment": " Utility Result functions.\n\n@docs filterErr, filterOk\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "filterErr",
        "comment": " Filter Errors from a List of Results.\n\n    results : Result String Int\n    results =\n        [ Err \"bad\"\n        , Ok 123\n        , Err \"bad2\"\n        ]\n\n\n    -- errorsOnly will be [\"bad\", \"bad2\"]\n\n    errorsOnly : List String\n    errorsOnly =\n        filterErr results\n\n",
        "type": "List (Result.Result error x) -> List error"
      },
      {
        "name": "filterOk",
        "comment": " Filter Oks from a List of Results.\n\n    results : Result String Int\n    results =\n        [ Err \"bad\"\n        , Ok 123\n        , Err \"bad2\"\n        ]\n\n\n    -- oksOnly will be [123]\n\n    oksOnly : List String\n    oksOnly =\n        filterOk results\n\n",
        "type": "List (Result.Result x value) -> List value"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Utils.Regex",
    "comment": " Utility Regex functions.\n\n@docs simpleReplacer, parametricReplacer, replace, replaceAll, replaceFirst, replaceSimple\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "parametricReplacer",
        "comment": " Parametric replacer for Regex that supports $1, $2, ... $9 Parametric Replacements\nN.B. $$ is an escape for $, e.g. $$1 will be $1 in the output\nN.B. any $n that isn't specified in the regular expression is untouched in the output\n\n    Regex.replace All (regex \"(\\\\d)([a-z])\") (parametricReplacer \"-$1$2$$2$3\") \"6a7b8c\" == \"-6a$2$3-7b$2$3-8c$2$3\"\n    Regex.replace (AtMost 2) (regex \"(\\\\d)([a-z])\") (parametricReplacer \"-$1$2$$2$3\") \"6a7b8c\" == \"-6a$2$3-7b$2$38c\"\n\n",
        "type": "String -> Regex.Match -> String"
      },
      {
        "name": "replace",
        "comment": " General replace.\n\n    replace All \"\\\\d\" (simpleReplacer \"_\") \"a1b2c3\" == \"a_b_c_\"\n    replace All \"(\\\\d)([a-z])\" (parametricReplacer \"-$1$2$$2$3\") \"6a7b8c\" == \"-6a$2$3-7b$2$3-8c$2$3\"\n\n",
        "type": "Regex.HowMany -> String -> (Regex.Match -> String) -> String -> String"
      },
      {
        "name": "replaceAll",
        "comment": " Simple replacement of ALL occurrences.\n\n    replaceAll \"\\\\d\" \"_\" \"a1b2c3\" == \"a_b_c_\"\n\n",
        "type": "String -> String -> String -> String"
      },
      {
        "name": "replaceFirst",
        "comment": " Simple replacement of FIRST occurrence.\n\n    replaceFirst \"\\\\d\" \"_\" \"a1b2c3\" == \"a_b2c3\"\n\n",
        "type": "String -> String -> String -> String"
      },
      {
        "name": "replaceSimple",
        "comment": " General simplified replace of specified number of occurrences.\n\n    replaceSimple All \"\\\\d\" \"_\" \"a1b2c3\" == \"a_b_c_\"\n\n",
        "type": "Regex.HowMany -> String -> String -> String -> String"
      },
      {
        "name": "simpleReplacer",
        "comment": " Simple replacer for Regex.\n\n    Regex.replace All \"\\\\d\" \"*\" \"x9y8z7\" simpleReplacer == \"x*y*z*\"\n\n",
        "type": "String -> Regex.Match -> String"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Utils.Record",
    "comment": " Utility Record functions.\n\n@docs makeComparable\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "makeComparable",
        "comment": " Make a record into a comparable string for use as a key in a Dict\n\n    import Utils.Record as Record\n\n    type alias DbConnectionInfo =\n        { host : String\n        , port_ : Int\n        , database : String\n        , user : String\n        , password : String\n        , timeout : Int\n        }\n\n    {-| make connection info comparable for Dictionaries\n    -}\n    makeComparable : DbConnectionInfo -> String\n    makeComparable =\n        Record.makeComparable\n            [ .host\n            , toString << .port_\n            , .database\n            , .user\n            , .password\n            ]\n\n`timeout` was left out on purpose in this example.\n\n",
        "type": "List (a -> String) -> a -> String"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Utils.Error",
    "comment": " Error Types and Encoding/Decoding\n\n@docs ErrorType, errorTypeEncoder, errorTypeDecoder\n\n",
    "aliases": [],
    "types": [
      {
        "name": "ErrorType",
        "comment": " Error Types\n",
        "args": [],
        "cases": [
          [
            "FatalError",
            []
          ],
          [
            "NonFatalError",
            []
          ],
          [
            "RetryableError",
            []
          ]
        ]
      }
    ],
    "values": [
      {
        "name": "errorTypeDecoder",
        "comment": " ErrorType decoder\n",
        "type": "Json.Decode.Decoder Utils.Error.ErrorType"
      },
      {
        "name": "errorTypeEncoder",
        "comment": " ErrorType encoder\n",
        "type": "Utils.Error.ErrorType -> Json.Encode.Value"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Utils.Ops",
    "comment": " Utility operators.\n\n  - [Boolean](#boolean)\n  - [List](#list)\n  - [Maybe](#maybe)\n  - [Result](#result)\n\n\n# Boolean\n\n@docs (?), (?!)\n\n\n# List\n\n@docs (!!)\n\n\n# Maybe\n\n@docs (?=), (?!=), (|?>), (|?->), (|?!->), (|?-->), (|?!-->), (|?--->), (|?!--->), (|?**>), (|?!**>), (|?***>), (|?!***>), (|?****>), (|?!****>)\n\n\n# Result\n\n@docs (|??>), (??=), (|??->), (|??-->), (|??**>), (|??***>), (|??****>)\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "!!",
        "comment": " Get item from List at index\n\n    items : List String\n    items =\n        [ \"Mickey's gloves\", \"Goofy's shoes\", \"Dumbo's feather\" ]\n\n    first2 : List String -> ( String, String )\n    first2 list =\n        ( list !! 0, list !! 1 )\n            |?!**>\n                ( \\_ -> Debug.crash \"missing first\"\n                , \\_ -> Debug.crash \"missing second\"\n                , identity\n                )\n\n",
        "type": "List a -> Int -> Maybe.Maybe a"
      },
      {
        "name": "?",
        "comment": " Simplify `if` syntax on a single line.\n\n    x : Int\n    x =\n        2\n\n\n    -- y will be \"not one\"\n\n    y : String\n    y =\n        x == 1 ? ( \"one\", \"not one\" )\n\n",
        "type": "Bool -> ( a, a ) -> a"
      },
      {
        "name": "?!",
        "comment": " Lazy version of ? operator for recursion or expensive functions that you don't want executed.\n\n    fact : Int -> Int\n    fact n =\n        (n <= 1) ?! ( \\_ -> 1, \\_ -> n * (fact <| n - 1) )\n\n",
        "type": "Bool -> ( () -> a, () -> a ) -> a"
      },
      {
        "name": "?!=",
        "comment": " Lazy version of ?= operator. (Since Elm is eager).\n\nThis is important if the default is a `Debug.crash` (or any side-effect function). You don't want it to be evaluated until it's needed. Since Elm is not lazy, we need to have\nspecial version of this.\n\n    x : Maybe Int\n    x =\n        Nothing\n\n    crashIfNothing : Int\n    crashIfNothing =\n        x ?!= (\\_ -> Debug.crash \"x cannot be Nothing, must be a internal programming bug\")\n\n",
        "type": "Maybe.Maybe a -> (() -> a) -> a"
      },
      {
        "name": "?=",
        "comment": " Maybe with default operator.\n\nSimplify `Maybe.withDefault` syntax\n\n    x : Int\n    x =\n        Just 1 ?= -1\n\n\n    -- y will be -1\n\n    y : Int\n    y =\n        Nothing ?= -1\n\n",
        "type": "Maybe.Maybe a -> a -> a"
      },
      {
        "name": "??=",
        "comment": " Simplified `Result.default` syntax.\nThis is different from Maybe.default since the Error Type may be different then the Ok Type in a Result.\nThis is why a function is passed to convert the Error Value to a value of Ok Type.\n\n    br : Result String Int\n    br =\n        Err \"Bad Things Happened\"\n\n    gr : Result String Int\n    gr =\n        Ok 123\n\n\n    -- b will be -1\n\n    b : Int\n    b =\n        br |??> (\\num -> 10 * num) ??= (\\_ -> -1)\n\n\n    -- g will be Ok 1230\n\n    g : Result String Int\n    g =\n        gr |??> (\\num -> 10 * num)\n\n",
        "type": "Result.Result err value -> (err -> value) -> value"
      },
      {
        "name": "|?!****>",
        "comment": " Lazy version of `(|?***>)`\n",
        "type": "( Maybe.Maybe a, Maybe.Maybe b, Maybe.Maybe c, Maybe.Maybe d ) -> ( () -> e, () -> e, () -> e, () -> e, ( a, b, c, d ) -> e ) -> e"
      },
      {
        "name": "|?!***>",
        "comment": " Lazy version of `(|?***>)`\n",
        "type": "( Maybe.Maybe a, Maybe.Maybe b, Maybe.Maybe c ) -> ( () -> d, () -> d, () -> d, ( a, b, c ) -> d ) -> d"
      },
      {
        "name": "|?!**>",
        "comment": " Lazy version of `(|?**>)`\n\nUseful when 2 maybes must have defaults or must not be `Nothing`.\n\n    bugMissing : String -> (a -> b)\n    bugMissing missing =\n        (\\_ -> Debug.crash (\"BUG: \" ++ missing ++ \" missing\"))\n\n    x : Maybe Int\n    x =\n        Just 1\n\n    y : Maybe Int\n    y =\n        Nothing\n\n    z : Int\n    z =\n        ( x, y )\n            |?!**>\n                ( bugMissing \"x\"\n                , bugMissing \"y\"\n                , \\( x, y ) -> x + y\n                )\n\n",
        "type": "( Maybe.Maybe a, Maybe.Maybe b ) -> ( () -> c, () -> c, ( a, b ) -> c ) -> c"
      },
      {
        "name": "|?!--->",
        "comment": " Lazy version of (|?--->)\n",
        "type": "Maybe.Maybe (Maybe.Maybe (Maybe.Maybe a)) -> ( () -> b, a -> b ) -> b"
      },
      {
        "name": "|?!-->",
        "comment": " Lazy version of (|?-->)\n\n    x : Maybe (Maybe Int)\n    x =\n        Nothing\n\n    y : Int\n    y =\n        x\n            |?!-->\n                ( \\_ -> Debug.crash \"BUG: x must never be Nothing here!!!\"\n                , \\x -> x * 10\n                )\n\n    z : Int\n    z =\n        x\n            |?!-->\n                ( \\_ ->\n                    Debug.log \"using default for x\"\n                        |> always 0\n                , \\x -> x * 10\n                )\n\n",
        "type": "Maybe.Maybe (Maybe.Maybe a) -> ( () -> b, a -> b ) -> b"
      },
      {
        "name": "|?!->",
        "comment": " Lazy version of (|?->)\n\nThe lazy version for side-effect functions, i.e. Debug.log.\n\n    x : Maybe Int\n    x =\n        Nothing\n\n    y : Int\n    y =\n        x |?!-> ( \\_ -> Debug.crash \"BUG: x must never be Nothing here!!!\", \\x -> x * 10 )\n\n    z : Int\n    z =\n        x\n            |?!->\n                ( \\_ ->\n                    Debug.log \"using default for x\"\n                        |> always 0\n                , \\x -> x * 10\n                )\n\n",
        "type": "Maybe.Maybe a -> ( () -> b, a -> b ) -> b"
      },
      {
        "name": "|?****>",
        "comment": " (|?->) for 4-tuple of Maybe's\n",
        "type": "( Maybe.Maybe a, Maybe.Maybe b, Maybe.Maybe c, Maybe.Maybe d ) -> ( e, e, e, e, ( a, b, c, d ) -> e ) -> e"
      },
      {
        "name": "|?***>",
        "comment": " (|?->) for 3-tuple of Maybe's\n",
        "type": "( Maybe.Maybe a, Maybe.Maybe b, Maybe.Maybe c ) -> ( d, d, d, ( a, b, c ) -> d ) -> d"
      },
      {
        "name": "|?**>",
        "comment": " (|?->) for 2-tuple of Maybe's\n\nUseful when 2 maybes need defaults.\n\n    x : Maybe Int\n    x =\n        Just 1\n\n    y : Maybe Int\n    y =\n        Nothing\n\n    z : Int\n    z =\n        ( x, y ) |?**> ( 0, 0, \\( x, y ) -> x + y )\n\n",
        "type": "( Maybe.Maybe a, Maybe.Maybe b ) -> ( c, c, ( a, b ) -> c ) -> c"
      },
      {
        "name": "|?--->",
        "comment": " Triple version of (|?->)\n",
        "type": "Maybe.Maybe (Maybe.Maybe (Maybe.Maybe a)) -> ( b, a -> b ) -> b"
      },
      {
        "name": "|?-->",
        "comment": " Double version of (|?->)\n\nSame as (|?->) but used with `Maybe (Maybe a)` instead of just `Maybe a`.\n\n    x : Maybe (Maybe Int)\n    x =\n        Nothing\n\n    y : Int\n    y =\n        x |?--> ( 0, \\x -> x * 10 )\n\n",
        "type": "Maybe.Maybe (Maybe.Maybe a) -> ( b, a -> b ) -> b"
      },
      {
        "name": "|?->",
        "comment": " Maybe.map combined with Maybe.withDefault (or |?> combined with ?=)\n\nThis combines two operators with the error case first, i.e. the Nothing.\n\n    x : Maybe Int\n    x =\n        Nothing\n\n    y : Int\n    y =\n        x |?-> ( 0, \\x -> x * 10 )\n\n",
        "type": "Maybe.Maybe a -> ( b, a -> b ) -> b"
      },
      {
        "name": "|?>",
        "comment": " Maybe.map operator\n\nSimplify `Maybe.map` syntax.\n\n    x : Maybe Int\n    x =\n        Just 1\n\n\n    -- y will be Just 10\n\n    y : Maybe Int\n    y =\n        x |?> (\\num -> 10 * num)\n\n\n    -- z will be 10\n\n    z : Int\n    z =\n        x |?> (\\num -> 10 * num) ?= 0\n\n",
        "type": "Maybe.Maybe a -> (a -> b) -> Maybe.Maybe b"
      },
      {
        "name": "|??****>",
        "comment": " (|??->) for 4-tuple of Results\n",
        "type": "( Result.Result x a , Result.Result x b , Result.Result x c , Result.Result x d ) -> ( x -> e, x -> e, x -> e, x -> e, ( a, b, c, d ) -> e ) -> e"
      },
      {
        "name": "|??***>",
        "comment": " (|??->) for 3-tuple of Results\n",
        "type": "( Result.Result x a, Result.Result x b, Result.Result x c ) -> ( x -> d, x -> d, x -> d, ( a, b, c ) -> d ) -> d"
      },
      {
        "name": "|??**>",
        "comment": " (|??->) for 2-tuple of Results\n\n    crash : String -> String -> x\n    crash which error =\n        Debug.crash (which ++ \" has the following error: \" ++ error)\n\n    ar : Result String Int\n    ar =\n        Ok 10\n\n    br : Result String Int\n    br =\n        Ok 20\n\n\n    -- sum will be 30\n\n    sum : Int\n    sum =\n        ( ar, br )\n            |??**>\n                ( crash \"a\"\n                , crash \"b\"\n                , \\( a, b ) -> a + b\n                )\n\n",
        "type": "( Result.Result x a, Result.Result x b ) -> ( x -> c, x -> c, ( a, b ) -> c ) -> c"
      },
      {
        "name": "|??-->",
        "comment": " Double version of (|?->)\n\n    crash : String -> (a -> b)\n    crash error =\n        (\\_ -> Debug.crash error)\n\n    brr : Result String (Result String Int)\n    brr =\n        Ok <| Err \"Bad Things Happened\"\n\n\n    -- b will be -1\n\n    b : Int\n    b =\n        brr\n            |??-->\n                ( crash \"fatal error\"\n                , \\_ -> -1\n                , \\num -> 10 * num\n                )\n\n",
        "type": "Result.Result a (Result.Result b c) -> ( a -> d, b -> d, c -> d ) -> d"
      },
      {
        "name": "|??->",
        "comment": " Result.map combined with (??=) (or |??> combined with ??=)\n\nThis combines two operators with the error case first.\n\n    br : Result String Int\n    br =\n        Err \"Bad Things Happened\"\n\n\n    -- b will be -1\n\n    b : Int\n    b =\n        br |??-> ( \\_ -> -1, \\num -> 10 * num )\n\n",
        "type": "Result.Result a b -> ( a -> c, b -> c ) -> c"
      },
      {
        "name": "|??>",
        "comment": " Result.map operator\n\nSimplified `Result.map` syntax.\n\n    br : Result String Int\n    br =\n        Err \"Bad Things Happened\"\n\n    gr : Result String Int\n    gr =\n        Ok 123\n\n\n    -- b will be Err \"Bad Things Happened\"\n\n    b : Result String Int\n    b =\n        br |??> (\\num -> 10 * num)\n\n\n    -- g will be Ok 1230\n\n    g : Result String Int\n    g =\n        gr |??> (\\num -> 10 * num)\n\n",
        "type": "Result.Result a b -> (b -> c) -> Result.Result a c"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Utils.Log",
    "comment": " Log Types.\n\n@docs LogLevel\n\n",
    "aliases": [],
    "types": [
      {
        "name": "LogLevel",
        "comment": " Logging Level\n",
        "args": [],
        "cases": [
          [
            "LogLevelFatal",
            []
          ],
          [
            "LogLevelError",
            []
          ],
          [
            "LogLevelWarn",
            []
          ],
          [
            "LogLevelInfo",
            []
          ],
          [
            "LogLevelDebug",
            []
          ],
          [
            "LogLevelTrace",
            []
          ]
        ]
      }
    ],
    "values": [],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Utils.Func",
    "comment": " Functional utilities functions.\n\n@docs apply, apply2, apply3, apply4 , compose, compose2 , compose3 , compose4 , compose5, compose6, compose7, compose8\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "apply",
        "comment": " Apply 1 params\n",
        "type": "a -> (a -> b) -> b"
      },
      {
        "name": "apply2",
        "comment": " Apply 2 params\n\n    log : number -> String -> String -> number\n    log num prefix1 prefix2 =\n        Debug.log (prefix1 ++ prefix2) num\n\n    nums : List number\n    nums =\n        List.map (apply2 \"prefix1\" \"prefix2\")\n            [ log 1\n            , log 2\n            ]\n\n\n    {-\n       nums = [1, 2]\n\n       Outputs to console:\n\n           prefix1prefix2: 1\n           prefix1prefix2: 2\n\n    -}\n\n",
        "type": "a -> b -> (a -> b -> c) -> c"
      },
      {
        "name": "apply3",
        "comment": " Apply 3 params\n",
        "type": "a -> b -> c -> (a -> b -> c -> d) -> d"
      },
      {
        "name": "apply4",
        "comment": " Apply 4 params\n",
        "type": "a -> b -> c -> d -> (a -> b -> c -> d -> e) -> e"
      },
      {
        "name": "compose",
        "comment": " Compose where first function takes 1 parameters\n",
        "type": "(b -> c) -> (a -> b) -> a -> c"
      },
      {
        "name": "compose2",
        "comment": " Compose where first function takes 2 parameters\n\n    add : number -> number -> number\n    add a b =\n        a + b\n\n    mult10 : number -> number\n    mult10 x =\n        x * 10\n\n    addMult10 : number -> number -> number\n    addMult10 =\n        compose2 mult10 add\n\n    x : number\n    x =\n        addMult10 2 3\n\n\n    {- 60 -}\n\n",
        "type": "(c -> d) -> (a -> b -> c) -> a -> b -> d"
      },
      {
        "name": "compose3",
        "comment": " Compose where first function takes 3 parameters\n",
        "type": "(d -> e) -> (a -> b -> c -> d) -> a -> b -> c -> e"
      },
      {
        "name": "compose4",
        "comment": " Compose where first function takes 4 parameters\n",
        "type": "(e -> f) -> (a -> b -> c -> d -> e) -> a -> b -> c -> d -> f"
      },
      {
        "name": "compose5",
        "comment": " Compose where first function takes 5 parameters\n",
        "type": "(f -> g) -> (a -> b -> c -> d -> e -> f) -> a -> b -> c -> d -> e -> g"
      },
      {
        "name": "compose6",
        "comment": " Compose where first function takes 6 parameters\n",
        "type": "(g -> h) -> (a -> b -> c -> d -> e -> f -> g) -> a -> b -> c -> d -> e -> f -> h"
      },
      {
        "name": "compose7",
        "comment": " Compose where first function takes 7 parameters\n",
        "type": "(h -> i) -> (a -> b -> c -> d -> e -> f -> g -> h) -> a -> b -> c -> d -> e -> f -> g -> i"
      },
      {
        "name": "compose8",
        "comment": " Compose where first function takes 8 parameters\n",
        "type": "(i -> j) -> (a -> b -> c -> d -> e -> f -> g -> h -> i) -> a -> b -> c -> d -> e -> f -> g -> h -> j"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  },
  {
    "name": "Utils.List",
    "comment": " Utility List functions.\n\n@docs to2Tuple, to3Tuple, to4Tuple, to5Tuple, to6Tuple, to7Tuple, to8Tuple, to9Tuple\n\n",
    "aliases": [],
    "types": [],
    "values": [
      {
        "name": "to2Tuple",
        "comment": " Take a list of length 2 or greater and convert it into an 2-tuple dropping any extra elements\n",
        "type": "List a -> ( a, a )"
      },
      {
        "name": "to3Tuple",
        "comment": " Take a list of length 3 or greater and convert it into an 3-tuple dropping any extra elements\n",
        "type": "List a -> ( a, a, a )"
      },
      {
        "name": "to4Tuple",
        "comment": " Take a list of length 4 or greater and convert it into an 4-tuple dropping any extra elements\n",
        "type": "List a -> ( a, a, a, a )"
      },
      {
        "name": "to5Tuple",
        "comment": " Take a list of length 5 or greater and convert it into an 5-tuple dropping any extra elements\n",
        "type": "List a -> ( a, a, a, a, a )"
      },
      {
        "name": "to6Tuple",
        "comment": " Take a list of length 6 or greater and convert it into an 6-tuple dropping any extra elements\n",
        "type": "List a -> ( a, a, a, a, a, a )"
      },
      {
        "name": "to7Tuple",
        "comment": " Take a list of length 7 or greater and convert it into an 7-tuple dropping any extra elements\n",
        "type": "List a -> ( a, a, a, a, a, a, a )"
      },
      {
        "name": "to8Tuple",
        "comment": " Take a list of length 8 or greater and convert it into an 8-tuple dropping any extra elements\n",
        "type": "List a -> ( a, a, a, a, a, a, a, a )"
      },
      {
        "name": "to9Tuple",
        "comment": " Take a list of length 9 or greater and convert it into an 9-tuple dropping any extra elements\n",
        "type": "List a -> ( a, a, a, a, a, a, a, a, a )"
      }
    ],
    "generated-with-elm-version": "0.18.0"
  }
]