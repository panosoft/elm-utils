# Utils.Json

Utility JSON functions.

- [(///)](#)
- [(<||)](#-1)
- [decConvertDict](#decconvertdict)
- [decDict](#decdict)
- [encDict](#encdict)
- [encMaybe](#encmaybe)
- [resultEncoder](#resultencoder)
- [resultDecoder](#resultdecoder)
- [resultEncode](#resultencode)
- [resultDecode](#resultdecode)

### **(///)**
```elm
(///) : Json.Decode.Decoder a -> a -> Json.Decode.Decoder a
```

Operator to provide a default for a Decoder.

```elm
type alias User =
    { name : String
    , age : Int
    , amount : Float
    , twelve : Int
    , address : Address
    }

userDecoder : Json.Decoder User
userDecoder =
    Json.succeed User
        <|| ("name" := string)
        <|| ("age" := int)
        <|| (("amount" := float) /// 100)
        <|| Json.succeed 12
        <|| ("address" := addressDecoder)
```

---

### **(<||)**
```elm
(<||) : Json.Decode.Decoder (a -> b) -> Json.Decode.Decoder a -> Json.Decode.Decoder b
```

Operator to allow stringing decoders together to construct a record via its constructor.

```elm
type alias User =
    { name : String
    , age : Int
    , amount : Float
    , twelve : Int
    , address : Address
    }

userDecoder : Json.Decoder User
userDecoder =
    Json.succeed User
        <|| ("name" := string)
        <|| ("age" := int)
        <|| ("amount" := float)
        <|| Json.succeed 12
        <|| ("address" := addressDecoder)
```

---

### **decConvertDict**
```elm
decConvertDict : (a -> value) -> Json.Decode.Decoder comparable -> Json.Decode.Decoder a -> Json.Decode.Decoder (Dict comparable value)
```

Convenience function for decoding a Dictionary WITH a value converstion function from a JS object of the following form:

```js
{
```elm
keys: [
    // keys encoded here
],
values: [
    // values encoded here
]
```

}
```

```elm
import Json.Decode as JD exposing (..)

type alias Model =
    { ids : Dict Int (Set String)
    , ages : Dict String Int
    }

-- here json is a JSON string that was generated by encDict
JD.decodeString
    ((JD.succeed Model)
        <|| ("ids" := Json.decConvertDict Set.fromList JD.int (JD.list JD.string))
        <|| ("ages" := Json.decDict JD.string JD.int)
    )
    json
```

---

### **decDict**
```elm
decDict : Json.Decode.Decoder comparable -> Json.Decode.Decoder value -> Json.Decode.Decoder (Dict comparable value)
```

Convenience function for decoding a Dictionary WITHOUT a value conversion function.

from a JS object of the following form:

```js
{
   keys: [
```elm
   // keys encoded here
```

   ],
   values: [
```elm
   // values encoded here
```

   ]
}
```

```elm
import Json.Decode as JD exposing (..)

type alias Model =
   { ids : Dict Int (Set String)
   , ages : Dict String Int
   }

-- here json is a JSON string that was generated by encDict
JD.decodeString
   ((JD.succeed Model)
       <|| ("ids" := Json.decConvertDict Set.fromList JD.int (JD.list JD.string))
       <|| ("ages" := Json.decDict JD.string JD.int)
   )
   json
```

---

### **encDict**
```elm
encDict : (comparable -> Json.Encode.Value) -> (value -> Json.Encode.Value) -> Dict comparable value -> Json.Encode.Value
```

Convenience function for encoding a Dictionary to a JS object of the following form:

```js
{
```elm
keys: [
    // keys encoded here
],
values: [
    // values encoded here
]
```

}
```

```elm
import Json.Encode as JE exposing (..)

type alias Model =
    { ids : Dict Int (Set String)
    , ages : Dict String Int
    }

JE.encode 0 <|
    JE.object
        [ ( "ids", Json.encDict JE.int (JE.list << List.map JE.string << Set.toList) model.ids )
        , ( "ages", Json.encDict JE.string JE.int model.ages )
        ]
```

---

### **encMaybe**
```elm
encMaybe : (a -> Json.Encode.Value) -> Maybe a -> Json.Encode.Value
```

Convenience function for encoding a Maybe with a encoder and NULL default.

```elm
import Json.Encode as JE exposing (..)

JE.encode 0 <|
    JE.object
        [ ( "street", Json.encMaybe JE.string address.street )
        , ( "city", Json.encMaybe JE.string address.city )
        , ( "state", Json.encMaybe JE.string address.state )
        , ( "zip", Json.encMaybe JE.string address.zip )
        ]
```

---

### **resultEncoder**
```elm
resultEncoder : (error -> Json.Encode.Value) -> (okay -> Json.Encode.Value) -> Result error okay -> Json.Encode.Value
```

Elm Result encoder

Will create a JS object with either an `okay` key or an `error` key.

```elm
import Json.Encode as JE exposing (..)

type alias Thing =
{ id : Int
, result : Result String Int
}

thingEncoder : Thing -> JE.Value
thingEncoder thing =
JE.object
[ ( "id", JE.int thing.id )
, ( "result", resultEncoder JE.string JE.int thing.result )
]
```

---

### **resultDecoder**
```elm
resultDecoder : Json.Decode.Decoder error -> Json.Decode.Decoder okay -> Json.Decode.Decoder (Result error okay)
```

Elm Result decoder

Expects a JS object with either an `okay` key or an `error` key.

```elm
import Json.Decode as JD exposing (..)

type alias Thing =
    { id : Int
    , result : Result String Int
    }

thingDecoder : Decoder Thing
thingDecoder =
    (JD.succeed Thing)
        <|| (field "id" JD.int)
        <|| (field "result" <| resultDecoder JD.string JD.int)
```

---

### **resultEncode**
```elm
resultEncode : (error -> Json.Encode.Value) -> (okay -> Json.Encode.Value) -> Result error okay -> String
```

Encode Elm Result

Will create a JS object with either an `okay` key or an `error` key.

```elm
import Json.Encode as JE exposing (..)

type alias MyResult =
    Result String Int

encodedErrorResult : String
encodedErrorResult =
    resultEncode JE.string JE.int <| Err "This is an error"

encodedOkayResult : String
encodedOkayResult =
    resultEncode JE.string JE.int <| Ok 123
```

---

### **resultDecode**
```elm
resultDecode : Json.Decode.Decoder error -> Json.Decode.Decoder okay -> String -> Result String (Result error okay)
```

Decode Elm Result

Expects a JS object with either an `okay` key or an `error` key.

```elm
type alias MyResult =
    Result String Int

decodedErrorResult : Result String MyResult
decodedErrorResult =
    resultDecode JD.string JD.int """{"error": "This is an error"}"""

decodedOkayResult : Result String MyResult
decodedOkayResult =
    resultDecode JD.string JD.int """{"okay": 123}"""
```

